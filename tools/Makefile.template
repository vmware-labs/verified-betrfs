TOOLS=$(dir $(abspath $(filter %/Makefile.template,$(MAKEFILE_LIST))))
ROOT=$(abspath $(TOOLS)/..)/
DAFNY_CMD="$(ROOT)/.dafny/bin/dafny"

BUILD_DIR=$(ROOT)build
export ROOT

TARGET_DIR_PATH=$(shell realpath --relative-to $(ROOT) .)

define transform-targets
	$(patsubst %.dfy,$(BUILD_DIR)/$(TARGET_DIR_PATH)/%.verified,$1)
endef

#
# Shouldn't have to modify anything below here.
#

TARGET_VERIFIEDS=$(call transform-targets,$(TARGET_SRCS))
TARGET_DEPS=$(patsubst %.verified,%.deps,$(TARGET_VERIFIEDS))

#$(warning TARGET_SRCS $(TARGET_SRCS))
#$(warning TARGET_VERIFIEDS $(TARGET_VERIFIEDS))
#$(warning TARGET_DEPS $(TARGET_DEPS))

all: $(TARGET_VERIFIEDS)

clean:
	rm -rf $(BUILD_DIR)

###############################################
#####  Build tree  ############################
###############################################
# http://ismail.badawi.io/blog/2017/03/28/automatic-directory-creation-in-make/
.PRECIOUS: $(BUILD_DIR)/. $(BUILD_DIR)%/.
.SECONDEXPANSION:

$(BUILD_DIR)/.:
	mkdir -p $@

$(BUILD_DIR)%/.:
	mkdir -p $@

.PRECIOUS: $(BUILD_DIR)/%/dir.deps
$(warning BUILD_DIR $(BUILD_DIR))
$(BUILD_DIR)/%/dir.deps: $(ROOT)% | $$(@D)/.
	$(ROOT)tools/deps-for-dfy.py $<

#include $(TARGET_DEPS)
DIR_DEPS=$(BUILD_DIR)/$(TARGET_DIR_PATH)/dir.deps
$(warning DIR_DEPS $(DIR_DEPS))
# TODO bug: deps are only checked for the directory we started make in,
# but you can make targets in any directory using their full paths. Ugh
# I hate make.
include $(DIR_DEPS)

# jonh thinks we don't want this wildcard include: it's unsound in a surprising way.
# The single include above is clumsy because it requires deps-for-dafny to emit
# transitive closure of deps, but at least we know what it does and when it does it.
#rwildcard=$(wildcard $1$2) $(foreach d,$(wildcard $1*),$(call rwildcard,$d/,$2))
#include $(call rwildcard,$(BUILD_DIR)/,*.deps)

# This was cool until someone tried to run it on MacOS.
#TIME=time -f "real %es cpu %Us"
TIME=time

# .synchk: Dafny syntax check
$(BUILD_DIR)/%.synchk: $(ROOT)%.dfy | $$(@D)/.
	$(TIME) $(DAFNY_CMD) /compile:0 /dafnyVerify:0 $< | tee $@

# .verchk: Dafny file-local verification
$(BUILD_DIR)/%.verchk: $(ROOT)%.dfy | $$(@D)/.
	$(TIME) $(DAFNY_CMD) /compile:0 $< 2>&1 | tee $@

# .verified: Aggregate result of verification for this file and
# its dependencies.
.PRECIOUS: $(BUILD_DIR)/%.verchk
AGGREGATE_TOOL=$(ROOT)tools/aggregate-verchk.py
$(BUILD_DIR)/%.verified: $(BUILD_DIR)/%.verchk $(AGGREGATE_TOOL) | $$(@D)/.
	$(AGGREGATE_TOOL) $^ | tee $@

# .cs: C-Sharp output from compiling a Dafny file (which includes all deps)
# In principle, building code should depend on .verified! But we want
# to play with perf with not-entirely-verifying trees.
$(BUILD_DIR)/%.cs: $(ROOT)%.dfy | $$(@D)/.
	$(eval TMPNAME=$(patsubst %.s.cs,%-s.cs,$(patsubst %.i.cs,%-i.cs,$@)))	 #eval trick to assign make var inside rule
	# Dafny irritatingly removes the '.i' presuffix.
	$(TIME) $(DAFNY_CMD) /compile:0 /noVerify /spillTargetCode:3 /countVerificationErrors:0 /out:$(TMPNAME) $<
	mv $(TMPNAME) $@

# .cpp: C++ output from compiling a Dafny file (which includes all deps)
$(BUILD_DIR)/%.cpp: $(ROOT)%.dfy | $$(@D)/.
	$(eval TMPNAME=$(patsubst %.cpp,%-i.cpp,$@))	 #eval trick to assign make var inside rule
	# Dafny irritatingly removes the '.i' presuffix.
	$(TIME) $(DAFNY_CMD) /compile:0 /noVerify /spillTargetCode:3 /countVerificationErrors:0 /out:$(TMPNAME) /compileTarget:cpp $<
	mv $(TMPNAME) $@

# .status.pdf: a dependency graph of .dfy files labeled with verification result status.
#
$(BUILD_DIR)/%.status.pdf: $(ROOT)%.dfy | $$(@D)/.
STATUS_TOOL=$(ROOT)tools/dep-graph.py
$(BUILD_DIR)/%.status.pdf: $(ROOT)%.dfy $(BUILD_DIR)/%.verified $(STATUS_TOOL) | $$(@D)/.
	$(eval DOTNAME=$(patsubst %.status.pdf,%.dot,$@))	 #eval trick to assign make var inside rule
	$(STATUS_TOOL) $< $(DOTNAME)
	@tred < $(DOTNAME) | dot -Tpdf -o$@
